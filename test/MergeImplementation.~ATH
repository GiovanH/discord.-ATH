//Why? Because I'm insane, that's why.
//There's probably something wrong with this somewhere

FABRICATE MERGESORT (LIST) {
	print ("Merge sort algo start.\n");
	INSPECT (-1);
	REPLICATE CURR LIST;
	BIFURCATE CURR[HEAD, TAIL];
	
	BIFURCATE HEAD[INDEX, VALUE];
	DEBATE (INDEX > 0) {
		PROCREATE LEFT NULL;
		PROCREATE RIGHT NULL;
		
		REPLICATE LENGTH ((INDEX + 1) /_ 2);
		print ("Mid: ~d\n", LENGTH);
		PROCREATE CNTL 0;
		PROCREATE CNTR 0;
		PROCREATE BLAH 0;
		~ATH(BLAH) {
			print ("BLUH\n");
			BIFURCATE CURR[HEAD, TAIL];
			BIFURCATE HEAD[I, VAL];
			DEBATE (I < LENGTH) {
				AGGREGATE [CNTL, VAL]NODE;
				AGGREGATE [NODE, LEFT]LEFT;
				REPLICATE CNTL (CNTL + 1);
				print ("Added an item (~d) to the left stack.\n", VAL);
			} UNLESS {
				AGGREGATE [CNTR, VAL]NODE;
				AGGREGATE [NODE, RIGHT]RIGHT;
				REPLICATE CNTR (CNTR + 1);
				print ("Added an item (~d) to the right stack.\n", VAL);
			}
			REPLICATE CURR TAIL;
			DEBATE (CURR) {
				BLAH.DIE();
			}
		} EXECUTE(NULL);
		//Current error is somewhere before this line
		print ("Split and recursed.\n");
		
		REPLICATE LEFT EXECUTE (MERGESORT, LEFT);
		REPLICATE RIGHT EXECUTE (MERGESORT, RIGHT);
		AGGREGATE [LEFT, RIGHT]TOMERGE;
		REPLICATE SORTEDLIST EXECUTE (MERGE, TOMERGE);
		print ("Going back now...\n");
		DIVULGATE SORTEDLIST;
	} UNLESS {
		print ("Lonely boi\n");
		DIVULGATE CURR;
	}
}

FABRICATE MERGE (LISTS) {
	print ("Merging...\n");
	PROCREATE RESULT NULL;
	PROCREATE CTR 0;

	BIFURCATE LISTS[LEFTY, RIGHTY];
	REPLICATE CHECK (LEFTY && RIGHTY);
	/*
		Logic check:
		We need the following loop to stop when at least one of the
		lists, LEFTY or RIGHTY, is dead.
		0, 0 should return dead
		0, 1 should return dead
		1, 0 should return dead
		1, 1 should return alive
	*/
	~ATH(CHECK) {
		BIFURCATE LEFTY[HEADL, TAILL];
		BIFURCATE HEADL[X, VALL];
		
		BIFURCATE RIGHTY[HEADR, TAILR];
		BIFURCATE HEADR[Y, VALR];
		
		DEBATE (VALL >= VALR) {
			AGGREGATE [CTR, VALL]ITEM;
			REPLICATE LEFTY TAILL;
		} UNLESS {
			AGGREGATE [CTR, VALR]ITEM;
			REPLICATE RIGHTY TAILR;
		}
		AGGREGATE [ITEM, RESULT]RESULT;
		REPLICATE CTR (CTR + 1);
		REPLICATE CHECK (LEFTY && RIGHTY);
	} EXECUTE(NULL);
	
	//Only one of these will be entered
	~ATH(LEFTY) {
		BIFURCATE LEFTY[HEADL, TAILL];
		BIFURCATE HEADL[X, VALL];
		AGGREGATE [CTR, VALL]ITEM;
		AGGREGATE [ITEM, RESULT]RESULT;
		REPLICATE CTR (CTR + 1);
		REPLICATE LEFTY TAILL;
	} EXECUTE(NULL);
	~ATH(RIGHTY) {
		BIFURCATE RIGHTY[HEADR, TAILR];
		BIFURCATE HEADR[Y, VALR];
		AGGREGATE [CTR, VALR]ITEM;
		AGGREGATE [ITEM, RESULT]RESULT;
		REPLICATE CTR (CTR + 1);
		REPLICATE RIGHTY TAILR;
	} EXECUTE(NULL);
	
	print("Merged!\n");
	DIVULGATE RESULT;
}

PROCREATE LOOP;
PROCREATE LIST NULL;
PROCREATE COUNT 0;
~ATH(LOOP) {
	print ("Select action:\n");
	print ("[1] Add an integer to the list\n");
	print ("[2] Sort and print list\n");
	print ("[3] Exit\n");
	input CHOICE "";
	
	DEBATE (CHOICE == 3) {
		LOOP.DIE();
	} UNLESS (CHOICE == 2) {
		DEBATE (LIST) {
			REPLICATE LIST EXECUTE (MERGESORT, LIST);
			print("List was successfully sorted.\n");
			// MergeImplementation is written so it sorts the values in
			// decreasing order to make it easier to print
			REPLICATE SORTED LIST;
			
			PROCREATE END;
			~ATH(END) {
				BIFURCATE SORTED[HEAD, TAIL];
				BIFURCATE HEAD[INDEX, VALUE];
				print ("~d\n", VALUE);
				DEBATE (TAIL) {
					END.DIE();
				}
			} EXECUTE(NULL);
		} UNLESS {
			print ("Queue is empty.\n");
		}
	} UNLESS (CHOICE == 1) {
		input ITEM "Integer to add :";
		AGGREGATE [COUNT, ITEM]HEAD;
		AGGREGATE [HEAD, LIST]LIST;
		REPLICATE COUNT (COUNT + 1);
	} UNLESS {
		print ("Invalid input.");
	}
} EXECUTE(NULL);
THIS.DIE();
